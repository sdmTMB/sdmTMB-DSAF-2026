<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Future directions in spatiotemporal species distribution modelling</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <script src="libs/header-attrs-2.30/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="theme.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Future directions in spatiotemporal species distribution modelling
]
.subtitle[
## DFO DSAF workshop
]
.author[
### 
]
.date[
### January 12–16 2026
]

---


&lt;!-- Build with: xaringan::inf_mr() --&gt;





# Multivariate estimation

A major focus of VAST and tinyVAST

Thus far has we've kept this as an intentional difference between sdmTMB/VAST/tinyVAST

You *can* fit multivariate models in sdmTMB assuming you want the species, length bins, etc. to have independent fields

See the [multispecies sdmTMB vignette](https://sdmtmb.github.io/sdmTMB/articles/multispecies.html)

---

# Combining multiple data types

.small[
Lets you combine presence/absence, count, and continuous positive data in the same model.

Currently fully functional [on a branch](https://github.com/sdmTMB/sdmTMB/tree/multiple-data). To be merged into `main` branch shortly. A [vignette is available](https://github.com/sdmTMB/sdmTMB/blob/multiple-data/vignettes/articles/multi-family.Rmd).

Same interface as tinyVAST

```r
family_list &lt;- list(
  binomial = binomial(link = "cloglog"),
  nbinom2 = nbinom2(),
  delta_lognormal = delta_lognormal(type = "poisson-link")
)
```
]

.tiny[
Grüss, A., and Thorson, J.T. 2019. Developing spatio-temporal models using multiple data types for evaluating population trends and habitat usage. ICES Journal of Marine Science 76(6): 1748–1761. &lt;https://doi.org/10.1093/icesjms/fsz075&gt;.
]

---

### "Distributed lag" models

.xsmall[
Estimated spatial, temporal, or spatiotemporal diffusive effects of covariates

Mostly finished in a branch of sdmTMB, to be merged in soon
]

&lt;img src="images/diffusion.png" width="68%" /&gt;

.tiny[
Lindmark, M., Anderson, S.C., and Thorson, J.T. 2025. Estimating scale-dependent covariate responses using two-dimensional diffusion derived from the stochastic partial differential equation method. Methods in Ecology and Evolution. &lt;https://doi.org/10.1111/2041-210X.70177&gt;
]

---

# Much faster MCMC sampling with SNUTS

Sparse NUTS (No-U-Turn Sampler)

Decorrelates the posterior using the joint precision matrix from TMB

Up to ~30x faster for sdmTMB models

Preprint out soon?

Folded into adnuts

&lt;https://github.com/Cole-Monnahan-NOAA/adnuts/&gt;

---

# Structural causal modelling

.small[
DAGs with GLMMs or as Dynamic Structural Equation Models (DSEM)
]

.pull-left[
&lt;img src="images/dag-rca.png" width=100% /&gt;
]

.pull-right[
.xtiny[
Arif, S., and MacNeil, M.A. (2022). Applying the structural causal model framework for observational causal inference in ecology. Ecological Monographs 93(1): e1554. &lt;https://doi.org/10.1002/ecm.1554&gt;.

Thorson, J. T., Andrews, A. G., Essington, T., &amp; Large, S. (2024). Dynamic structural equation models synthesize ecosystem dynamics constrained by ecological mechanisms. Methods in Ecology and Evolution 15(4): 744-755. &lt;https://doi.org/10.1111/2041-210X.14289&gt;

Wilson, K.L., Frid, A., and Anderson, S.C. 2025. Groundfish with diverse life histories increase in size and abundance with proximity to spatial protections. bioRxiv. &lt;https://doi.org/10.1101/2025.11.28.691246&gt;.

]
]

---

# An improved understanding of data integration

We're only starting to understand issues that can arise with expanded domain data integration

Best practices for combining different data types and surveys with different length selectivities

Integration of geostatistical and movement data in shared models
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "highlightLines": true,
  "countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
