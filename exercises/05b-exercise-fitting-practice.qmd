---
title: "Fitting spatial/spatiotemporal models"
format: html
editor: visual
execute:
  echo: true
  eval: true
---

# Goals:

-   Practice fitting spatial and spatiotemporal models with less guidance.
-   See an example of using an 'offset'.
-   Practice calculating an area-weighted biomass index, center of gravity, and other distribution metrics with less guidance.

```{r, message=FALSE, warning=FALSE}
library(sdmTMB)
library(dplyr)
library(ggplot2)
options(ggplot2.continuous.colour = "viridis")
options(ggplot2.continuous.fill = "viridis")
theme_set(theme_light())
```

We will work with lingcod data from the Queen Charlotte Sound synoptic survey:

# Data

```{r}
d <- readRDS(here::here("data/lingcod-qcs.rds"))
d$area_swept <- d$area_swept / 10000
glimpse(d)
```

Add UTM columns to the dataset. Use `utm_crs = 3156` to match the UTM zone 9 used in the grid.

```{r}
d <- add_utm_columns(d, units = "km", utm_crs = 3156) # exercise
```

Create a mesh with a `cutoff` value of `10` km.

# Mesh

```{r}
mesh <- make_mesh(d, c("X", "Y"), cutoff = 10) # exercise
plot(mesh)
```

We will run the following code to turn the `qcs_grid` grid built into the package into a grid with values for every year in the lingcod dataset.

# Grid

We'll expand the built-in survey grid to each year of our dataset:

```{r}
grid <- replicate_df(qcs_grid, "year", unique(d$year))
```

# Spatial model

This is how an 'offset' works:

-   log(catch_weight/area_swept) = b0 + b1 \* x
-   log(catch_weight) - log(area_swept) = b0 + b1 \* x
-   log(catch_weight) = b0 + b1 \* x + log(area_swept)
-   log(catch_weight) = b0 + b1 \* x + offset

Note the offset is the **log** of the effort variable.

Here, we could fit our model to catch weight with an area swept offset or to density. In other cases (e.g., count data), an offset lets us use a count distribution with an effort measure.

Fit a spatial model with a Tweedie family:

```{r}
fit_spatial <- sdmTMB(
  catch_weight ~ 0 + as.factor(year),
  spatial = "on", # answer
# spatial = , # exercise
  offset = log(d$area_swept),
  family = tweedie(), # answer
# family =  , # exercise
  mesh = mesh, # answer
# mesh =  , # exercise
  data = d, # answer
  silent = FALSE
)
```

```{r}
sanity(fit_spatial)
fit_spatial
```

Calculate theoretical quantile residuals (see `residuals.sdmTMB`; the `residuals()` method) and assign them to a new column `resid_sp` in `d`:

```{r}
d$resid_sp <- residuals(fit_spatial) # answer

ggplot(d, aes(X, Y, colour = resid_sp)) +
  geom_point() +
  facet_wrap(~year) +
  scale_colour_gradient2()

qqnorm(d$resid_sp)
abline(0, 1)
```

### Exercise:

1.  Did that fit reasonably well such that we can try adding the complexity of spatiotemporal fields?
2.  In addition to the fits, do the spatial residuals in any year show evidence of persistent spatial autocorrelation?
3.  How does the QQ plot look? How might we improve that in future modelling?

# Spatiotemporal model

Add IID spatiotemporal fields:

```{r}
fit <- sdmTMB(
  catch_weight ~ 0 + as.factor(year),
  time = "year", # answer
  spatial = "on", # answer
  spatiotemporal = "iid", # answer
  offset = log(d$area_swept),
  family = tweedie(), # answer
  mesh = mesh, # answer
  data = d,
  silent = FALSE
)
```

```{r}
sanity(fit)
```

```{r}
fit
```

```{r}
tidy(fit)

tidy(fit, effects = "ran_pars")
```

### Exercise:

1.  Is the spatial or spatiotemporal variance larger?
2.  Does that make sense? What does this mean biologically?

Calculate randomized quantile residuals into an object `resid`:

```{r}
set.seed(1)
resid <- residuals(fit, type = "mle-mvn") # answer
#resid <-  # exercise
```

How do the basic randomized quantile residuals look for the overall model? Is this better than the model with spatial random fields only? Why?

```{r}
qqnorm(resid)
abline(0, 1)
```

Predict on the newdata `grid` and set `return_tmb_object = TRUE`. Save the output to `pred`:

```{r}
pred <- predict(fit, newdata = grid, return_tmb_object = TRUE) # answer
# pred <-  # exercise
```

Because we set `return_tmb_object = TRUE`, the prediction data frame is in the list element `data`.

```{r}
glimpse(pred$data)
```

### Exercise:

1.  How do we turn these into response (catch weight) space?

## Plotting the model components spatially

```{r}
ggplot(pred$data, aes(X, Y, fill = exp(est_non_rf))) +
  geom_raster() +
  facet_wrap(~year) +
  coord_fixed() +
  ggtitle("Fixed effect predictions")
```

```{r}
ggplot(pred$data, aes(X, Y, fill = omega_s)) +
  geom_raster() +
  scale_fill_gradient2() +
  coord_fixed() +
  ggtitle("Spatial random field")
```

```{r}
ggplot(pred$data, aes(X, Y, fill = epsilon_st)) +
  geom_raster() +
  scale_fill_gradient2() +
  facet_wrap(~year) +
  coord_fixed() +
  ggtitle("Spatiotemporal random fields")
```

```{r}
ggplot(pred$data, aes(X, Y, fill = exp(est))) +
  geom_raster() +
  facet_wrap(~year) +
  scale_fill_viridis_c(trans = "log10") +
  coord_fixed() +
  ggtitle("Predictions")
```

# Calculating an area-weighted biomass index

Use `get_index()` to calculate an area-weighted biomass index. Save the output to `ind`.

```{r}
ind <- get_index(pred, area = 4, bias_correct = TRUE) # answer
# ind <-  # exercise
```

```{r}
ggplot(ind, aes(year, y = est, ymin = lwr, ymax = upr)) +
  geom_pointrange() +
  scale_y_continuous(limits = c(0, NA), expand = expansion(mult = c(0, 0.05)))
```

# Calculating the center of gravity

Use `get_cog()` to calculate the center of gravity (biomass-weighted mean latitude and longitude). You can set `bias_correct = FALSE` so this exercise is a bit faster. Save the output to `cog`. I suggest using `format = "wide"` because it will make plotting easier here.

```{r}
cog <- get_cog(pred, area = 4, bias_correct = FALSE, format = "wide") # answer
# cog <-  # exercise

ggplot(cog, aes(est_x, est_y, colour = year)) +
  geom_point() +
  geom_linerange(aes(xmin = lwr_x, xmax = upr_x)) +
  geom_linerange(aes(ymin = lwr_y, ymax = upr_y)) +
  scale_colour_viridis_c()
```

# Calculating the biomass-weighted mean depth

Try calculating biomass-weighted mean depth. The depth vector is in `grid$depth`. Use `get_weighted_average()`.

```{r}
mean_depth <- get_weighted_average(pred, area = 4, vector = grid$depth) # answer
# mean_depth <- # exercise

ggplot(mean_depth, aes(year, y = est, ymin = lwr, ymax = upr)) +
  geom_pointrange()
```

# Calculating effective area occupied

Try calculating effective area occupied with `get_eao()`. Don't forget to specify the cell area (2 x 2 km = 4 km^2^ here).

```{r}
eao <- get_eao(pred, area = 4) # answer
# eao <-  exercise

ggplot(eao, aes(year, y = est, ymin = lwr, ymax = upr)) +
  geom_pointrange()
```

# Calculating range edges

Try the 97.5% and 2.5% range edges with `get_range_edge()`. Remember that `get_range_edge()` takes simulation-based predictions.

```{r}
pred_sim <- predict(fit, newdata = grid, nsim = 200)
dim(pred_sim)

edges <- get_range_edge(pred_sim, axis = grid$Y) # answer
# edges <- get_range_edge(pred_sim, axis = <fill in here>) # exercise

ggplot(edges, aes(year, y = est, ymin = lwr, ymax = upr, group = quantile)) +
  geom_ribbon(fill = "grey90") +
  geom_line()
```
