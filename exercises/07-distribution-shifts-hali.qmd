---
title: "Stitching survey data"
format: html
editor: visual
execute:
  echo: true
  eval: true
---

# Goals:

```{r}
#| echo: false
#| message: false
#| warning: false
library(sdmTMB)
library(dplyr)
library(ggplot2)
options(ggplot2.continuous.colour = "viridis")
options(ggplot2.continuous.fill = "viridis")
options(ggplot2.discrete.colour = RColorBrewer::brewer.pal(8, "Set2"))
options(ggplot2.discrete.fill = RColorBrewer::brewer.pal(8, "Set2"))
theme_set(theme_light())
```

Range edges are useful metrics for understanding species distributions and how they change over time. The `get_range_edge()` function calculates range edges as density-weighted quantiles along a spatial axis (e.g., latitude, longitude, or depth). This approach follows methods used in Fredston et al. 2021 from VAST.

Range edges are calculated by:

1.  Ordering spatial locations along a user-specified axis
2.  Calculating the cumulative proportion of total density along that axis
3.  Finding positions where the cumulative proportion equals target quantiles
4.  Using simulation from the joint precision matrix to quantify uncertainty

In this vignette, we'll demonstrate calculating range edges for Pacific Spiny Dogfish (*Squalus suckleyi*) along the latitude axis on the west coast of Vancouver Island.

# Data

-   **trawl_id**: unique trawl ID, formatting varies with survey
-   **longitude**: longitude
-   **latitude**: latitude
-   **season**: season is assigned based on month
-   **year**: selected since 1993 to aligh with GLORYS data
-   **survey**: "NEFSC" , "DFO_NF", "DFO_MAR"
-   **date**: yyyy-mm-dd
-   **scientific_name**: scientific species name, "HIPPOGLOSSUS HIPPOGLOSSUS"
-   **total_biomass**: total weight caught in tow (kg)
-   **total_abundance** : total number caught in tow
-   **area_swept**: in square kilometers.
    -   NEFSC = constant(0.1317083)
    -   DFO_NF/DFO_Mar = based on distance towed and wing spread for respective gears
-   **presence**: binary presence absence indicator (1=present, 0=absent)
-   **CountTool**: 1 for plotting

```{r}
RVdata <- read.csv("~/src/Halibut_Paper2/data/TrawlSurvey_data/RV_Cleaned_Joined_Nov2025/All_Halibut_Nov2025.csv")
```

### Survey Descriptions

-   **NEFSC**: The Northeast Fisheries Science Center, a division of NOAAâ€™s National Marine Fisheries Service. Conducts spring and fall RV surveys covering an area from Cape Hatteras to the southern part of the Scotian Shelf. **to do: see if 2024 or 2025 are available**

-   **DFO_NF**: Fisheries and Oceans Canada, Newfoundland. Conducts spring and fall RV surveys, which span from the Laurentian Channel and up the coast of Labrador. Excluded from these data are NAFO regions beyond 2J where there is very little catch. **to do: see if 2025 are available**

-   **DFO_MAR**: The DFO Maritimes Region conducts spring and summer RV surveys, covering the Scotian Shelf, the Bay of Fundy, and Georges Bank, up to the Laurentian Channel

```{r mapdata}
folder <- "~/src/Halibut_Paper2/"
NAFO <-sf::st_read(file.path(folder, "Data/Mapping_shapefiles/Divisions.shp"))
crs <- sf::st_crs(NAFO)
EEZ <- sf::st_read(file.path(folder, "Data/Mapping_shapefiles/EEZ.shp"))
Hague <-  sf::st_read(file.path(folder, "Data/Mapping_shapefiles/HagueLine.shp"))
sf::st_crs(EEZ) <- crs
sf::st_crs(Hague) <- crs
Land <- rnaturalearth::ne_countries(scale = "large", returnclass = "sf")#high resolution land shapefile
#convert RV data to sf object
rv_sf <- sf::st_as_sf(RVdata, coords = c("longitude", "latitude"))
sf::st_crs(rv_sf) <- crs

# SurveyData<-ggplot() +
#   geom_sf(data = Land , color = "black", fill = "cornsilk") +
#   # geom_sf(data = filter(rv_sf, year == 2022), aes(color = survey),size =.8, shape=16) +
#   geom_sf(data = NAFO, color="dimgrey", fill = NA) +
#   geom_sf(data = EEZ, color="navy", linetype = "dashed", linewidth  = 1) +
#   geom_sf(data = Hague, color="navy", linewidth = .9) +
#   xlim(-80, -44) + ylim(35, 55)+
#   facet_wrap(~season)+
#   theme(axis.text.x = element_text(angle = 90, hjust = 1))
# SurveyData
```

```{r}
# dat <- filter(RVdata, season == "Spring", year < 2025, survey != "NEFSC")
dat <- filter(RVdata, season == "Spring", year < 2025, survey == "DFO_MAR")
is_even <- function(x) x %% 2 == 0
dat <- filter(dat, is_even(year))
nrow(dat)
table(dat$survey, dat$year)
dat <- dplyr::filter(dat, area_swept > 0) # !?
dat$season <- tolower(dat$season)
dat$date <- lubridate::ymd(dat$date)
dat$presence <- NULL
dat$CountTool <- NULL
dat$scientific_name <- NULL
dat <- rename(dat, catch_count = total_abundance, catch_weight = total_biomass)
dat$survey <- factor(dat$survey, levels = c("DFO_MAR", "DFO_NF", "NEFSC"))
dat$survey <- factor(dat$survey, levels = c("DFO_MAR", "DFO_NF"))

# table(dat$season, dat$survey)
# dat$season <- factor(dat$season, levels = c("summer", "spring", "fall"))
glimpse(dat)
```

```{r}
dat <- add_utm_columns(dat, utm_crs = 32622)
# dat <- filter(dat, Y < 5500)
mesh <- make_mesh(dat, c("X", "Y"), cutoff = 20)
plot(mesh)
plot(mesh$mesh)
mesh$mesh$n
```

```{r}
fit <- sdmTMB(
  catch_weight ~ 0 + factor(year),
  time = "year",
  family = delta_gamma(type = "poisson-link"),
  mesh = mesh,
  spatial = "on",
  spatiotemporal = "iid",
  data = dat,
  share_range = FALSE,
  offset = log(dat$area_swept),
  # anisotropy = TRUE,
  silent = FALSE
)
```

```{r}
fit
```

```{r}
plot_anisotropy(fit)

tidy(fit, "ran_pars")
tidy(fit)

set.seed(1)
s <- simulate(fit, nsim = 200, type = "mle-mvn")
dharma_residuals(s, fit)
```

```{r}
# Create 5x5 km grid in UTM space
dat_sf <- sf::st_as_sf(dat, coords = c("longitude", "latitude"), crs = 4326) |>
  sf::st_transform(crs = 32622)

# Create grid with 10km cells (10,000 meters) - polygons first
grid_sf <- sf::st_make_grid(
  dat_sf,
  cellsize = c(20000, 20000),
  what = "polygons"
)

# Find which grid cells contain data points
grid_with_data <- sf::st_intersects(grid_sf, dat_sf)
has_data <- lengths(grid_with_data) > 0

# Keep only grid cells with data and get centers
grid_sf <- sf::st_centroid(grid_sf[has_data])

# Convert to data frame with X, Y coordinates in km
grid <- sf::st_coordinates(grid_sf) |>
  as.data.frame() |>
  rename(X = X, Y = Y) |>
  mutate(X = X / 1000, Y = Y / 1000) |>   # convert meters to km
  filter(Y < 5500)

ggplot(grid, aes(X, Y)) +
  geom_tile() +
  geom_point(data = dat, mapping = aes(X, Y, colour = survey), pch = 21, alpha = 0.3, size = 0.1) +
  coord_equal()
```

```{r}
# Add depth to grid using marmap
library(marmap)

# Convert grid back to lon/lat for marmap
grid_lonlat <- grid |>
  mutate(
    X_m = X * 1000,
    Y_m = Y * 1000
  ) |>
  sf::st_as_sf(coords = c("X_m", "Y_m"), crs = 32622) |>
  sf::st_transform(crs = 4326) |>
  sf::st_coordinates() |>
  as.data.frame()

# Get bounding box with buffer
lon_range <- range(grid_lonlat$X)
lat_range <- range(grid_lonlat$Y)
buffer <- 0.5  # degrees

# Download bathymetry data
bathy <- getNOAA.bathy(
  lon1 = lon_range[1] - buffer,
  lon2 = lon_range[2] + buffer,
  lat1 = lat_range[1] - buffer,
  lat2 = lat_range[2] + buffer,
  resolution = 1  # 1 minute resolution
)

# Extract depth at grid points (negative values = below sea level)
depths <- get.depth(bathy, x = grid_lonlat$X, y = grid_lonlat$Y, locator = FALSE)

# Add depth to grid (convert to positive values for depth)
grid$depth <- abs(depths$depth)

# Check result
ggplot(grid, aes(X, Y, fill = depth)) +
  geom_tile() +
  scale_fill_viridis_c() +
  coord_equal() +
  labs(fill = "Depth (m)")
```

```{r}
grid <- replicate_df(grid, "year", unique(dat$year))
```

```{r}
pred <- predict(fit, newdata = grid, return_tmb_object = TRUE)

ggplot(pred$data, aes(X, Y, fill = est)) + geom_tile() +
  facet_wrap(~year)
ggplot(pred$data, aes(X, Y, fill = epsilon_st)) + geom_tile() +
  facet_wrap(~year) +
  scale_fill_gradient2()

ind <- get_index(pred)
ggplot(ind, aes(year, est, ymin = lwr, ymax = upr)) + geom_ribbon()

cog <- get_cog(pred, format = "wide")
ggplot(cog, aes(est_x, est_y, colour = year)) +
  geom_point() +
  geom_linerange(aes(xmin = lwr_x, xmax = upr_x)) +
  geom_linerange(aes(ymin = lwr_y, ymax = upr_y))

density_weighted_depth <- get_weighted_average(pred, vector = grid$depth)
```

```{r}
ggplot(density_weighted_depth, aes(year, est)) + geom_point()
```

We'll use the built-in `dogfish` dataset, which contains fisheries-independent trawl survey data from the west coast of Vancouver Island. The data includes catch weights, presence/absence, depth, and area swept.

```{r glimpse-dogfish}
glimpse(dogfish)
```

For prediction, we'll use the `wcvi_grid`, which provides a spatial grid covering the survey area:

```{r glimpse-grid}
glimpse(wcvi_grid)
```

# Fitting a spatiotemporal model

First, we'll construct a mesh for the spatial random effects:

```{r mesh, fig.asp=0.8}
mesh <- make_mesh(dogfish, c("X", "Y"), cutoff = 10)
```

Next, we'll fit a spatiotemporal model for dogfish density using a delta generalized-gamma family (Dunic et al. 2025). This models the positive catches with a generalized gamma distribution that works well for Pacific Dogfish given their occasional giant outlying catch values. A simpler Tweedie or delta-gamma family could have been used too. We'll include depth as a predictor using a quadratic effect:

```{r fit-model}
fit <- sdmTMB(
  catch_weight ~ poly(log(depth), 2),
  data = dogfish,
  mesh = mesh,
  family = delta_gengamma(type = "poisson-link"),
  spatial = "on",
  time = "year",
  spatiotemporal = "IID"
)
sanity(fit)
fit
```

The model shows both spatial and spatiotemporal variation, with depth having a strong relationship with dogfish density.

# Making predictions

To calculate range edges, we need to make predictions on a spatial grid that covers the area of interest. We'll replicate the `wcvi_grid` for each year in the dataset and generate predictions with simulation:

```{r predict}
# Create prediction grid for each year
years <- sort(unique(dogfish$year))
nd <- replicate_df(wcvi_grid, "year", years)

# Make predictions with simulations for uncertainty quantification
# Using nsim = 200 simulations from the joint precision matrix
# larger simulations will be more stable at the expense of speed and memory
set.seed(123)
pred <- predict(fit, newdata = nd, nsim = 200)
```

The `predict()` function with `nsim > 0` returns a matrix where each column represents one simulation draw from the joint precision matrix.

# Calculating range edges

Now we can calculate range edges along the latitude axis (Y coordinate). By default, `get_range_edge()` calculates the 2.5% and 97.5% quantiles, representing the lower and upper range edges. Here, we'll also add in the median (0.5) to find the center of the distribution.

```{r range-edges}
edges <- get_range_edge(pred, axis = nd$Y, quantiles = c(0.025, 0.50, 0.975))
head(edges)
```

The output includes:

-   `year`: the time slice
-   `quantile`: the quantile value (0.025 for lower edge, 0.500 for the median, 0.975 for upper edge)
-   `est`: the estimated position along the axis (latitude in this case)
-   `lwr` and `upr`: 95% confidence intervals for each quantile
-   `se`: standard error for each quantile

# Visualizing range edges

We can plot how the range edges change over time:

```{r plot-custom-edges, fig.width=7, fig.asp=0.5}
ggplot(edges, aes(year, est, colour = as.factor(quantile))) +
  geom_line(linewidth = 1) +
  geom_ribbon(
    aes(ymin = lwr, ymax = upr, fill = as.factor(quantile)),
    alpha = 0.2,
    colour = NA
  ) +
  labs(
    x = "Year",
    y = "Latitude (UTM km)",
    colour = "Quantile",
    fill = "Quantile"
  ) +
  scale_colour_discrete(labels = c("5%", "50%", "95%")) +
  scale_fill_discrete(labels = c("5%", "50%", "95%")) +
  theme_light()
```

This plot shows how the northern and southern range edges of dogfish have shifted over time, with uncertainty bands reflecting sampling and estimation uncertainty. The median line represents the center of the distribution.

# Accessing simulation draws

For custom analyses, you can access the raw simulation draws:

```{r sims}
edges_sims <- get_range_edge(pred, axis = nd$Y, return_sims = TRUE)
head(edges_sims)
```

This returns all simulation draws in long format, which can be useful for:

-   Custom uncertainty quantification
-   Calculating probabilities of range shifts
-   Comparing range edges between models or scenarios

For example, we could calculate the probability that the upper range edge (northern edge) has shifted northward between two time periods:

```{r prob-shift}
# Extract simulations for upper edge in first and last year
upper_first <- edges_sims |>
  filter(quantile == 0.975, year == min(year))

upper_last <- edges_sims |>
  filter(quantile == 0.975, year == max(year))

# Calculate shift for each simulation
shifts <- upper_last$.value - upper_first$.value[match(upper_last$.iteration, upper_first$.iteration)]

# Probability of northward shift
prob_north <- mean(shifts > 0)
cat("Probability of northward shift:", round(prob_north * 100, 1), "%\n")
```

We can plot that distribution:

```{r prob-shift-hist}
ggplot(data.frame(shifts = shifts), aes(shifts)) + geom_histogram()
```

If anything, the northern range has contracted here, which is consistent with previous research on this stock (Ward et al. 2024).

# Other axes

While we've demonstrated using latitude (Y), range edges can be calculated along any spatial axis. Common choices include:

-   **Longitude (X)**: for east-west range shifts
-   **Depth**: for depth range edges (e.g., shallow vs. deep distribution limits)
-   **Coastal distance**: for offshore/onshore distribution patterns
-   **Temperature**: if you have environmental covariates in your prediction grid

Simply provide the appropriate vector to the `axis` argument.

# References

Dunic, J.C., Conner, J., Anderson, S.C., and Thorson, J.T. 2025. The generalized gamma is a flexible distribution that outperforms alternatives when modelling catch rate data. ICES Journal of Marine Science 82(4): fsaf040. <https://doi.org/10.1093/icesjms/fsaf040>

Fredston, A. L., Pinsky, M., Selden, R. L., Szuwalski, C., Thorson, J. T., Gaines, S. D., & Halpern, B. S. (2021). Range edges of North American marine species are tracking temperature over decades. *Global Change Biology*, 27(13), 3145-3156. <https://doi.org/10.1111/gcb.15614>

Ward, E.J., Anderson, S.C., Barnett, L.A.K., English, P.A., Berger, H.M., Commander, C.J.C., Essington, T.E., Harvey, C.J., Hunsicker, M.E., Jacox, M.G., Johnson, K.F., Large, S., Liu, O.R., Richerson, K.E., Samhouri, J.F., Siedlecki, S.A., Shelton, A.O., Somers, K.A., and Watson, J.T. 2024. Win, lose, or draw: Evaluating dynamic thermal niches of northeast Pacific groundfish. PLOS Climate 3(11): e0000454. Public Library of Science. <https://doi.org/10.1371/journal.pclm.0000454>
